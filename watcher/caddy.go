package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

// Embedded templates for Caddyfile generation
var templates = map[string]string{
	"external": `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
{{AUTH_GROUPS_BLOCK}}
{{ALLOWLIST_BLOCK}}
}
`,
	"internal": `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
    import internal

    handle @internal {
{{HANDLE_CONTENT}}
    }
    abort
}
`,
	"cloudflare": `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
    import cloudflare

    handle @cloudflare {
{{HANDLE_CONTENT}}
    }
    abort
}
`,
}

// CaddyManager manages Caddyfile configurations
type CaddyManager struct {
	hostsDir         string
	allowlistManager *AllowlistManager
	configs          map[string]*CaddyConfig // configKey (container_network) -> config
	mu               sync.RWMutex
}

// ConfigInfo holds information about a configuration file
type ConfigInfo struct {
	Network     string
	Container   string
	Type        string
	Domains     []string
	Allowlist   []string
	Logging     bool
	TLS         bool
	Compression bool
	Header      bool
	Auth        bool
	Path        string
	Managed     bool
}

// NewCaddyManager creates a new CaddyManager
func NewCaddyManager(hostsDir string, allowlistManager *AllowlistManager) *CaddyManager {
	return &CaddyManager{
		hostsDir:         hostsDir,
		allowlistManager: allowlistManager,
		configs:          make(map[string]*CaddyConfig),
	}
}

// WriteConfig writes a Caddyfile configuration for a service
func (m *CaddyManager) WriteConfig(cfg *CaddyConfig) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Get template for this type
	tmpl, ok := templates[cfg.Type]
	if !ok {
		return fmt.Errorf("unknown config type: %s", cfg.Type)
	}

	// Format domains for Caddy: https://a.com, https://b.com
	var formattedDomains []string
	for _, d := range cfg.Domains {
		formattedDomains = append(formattedDomains, "https://"+d)
	}

	// Replace placeholders
	content := tmpl
	content = strings.ReplaceAll(content, "{{NETWORK}}", cfg.Network)
	content = strings.ReplaceAll(content, "{{DOMAINS}}", strings.Join(formattedDomains, ", "))
	content = strings.ReplaceAll(content, "{{UPSTREAM}}", cfg.Upstream)

	// Generate imports block
	// Note: don't import auth if auth_groups is set (we inline forward_auth in that case)
	var imports []string
	if cfg.Logging {
		imports = append(imports, "    import logging")
	}
	if cfg.TLS {
		imports = append(imports, "    import tls")
	}
	if cfg.Compression {
		imports = append(imports, "    import compression")
	}
	if cfg.Header {
		imports = append(imports, "    import header")
	}
	if cfg.Auth {
		// For external: always import auth (directive ordering works)
		// For internal/cloudflare with auth_groups: skip (we inline forward_auth in route block)
		if cfg.Type == "external" || len(cfg.AuthGroups) == 0 {
			imports = append(imports, "    import auth")
		}
	}
	content = strings.ReplaceAll(content, "{{IMPORTS}}", strings.Join(imports, "\n"))

	// Handle auth groups placeholder (only for external type)
	authGroupsBlock := m.generateAuthGroupsBlock(cfg)
	content = strings.ReplaceAll(content, "{{AUTH_GROUPS_BLOCK}}", authGroupsBlock)

	// Handle content inside handle blocks (for internal/cloudflare types)
	handleContent := m.generateHandleContent(cfg)
	content = strings.ReplaceAll(content, "{{HANDLE_CONTENT}}", handleContent)

	// Handle allowlist placeholder
	allowlistBlock := m.generateAllowlistBlock(cfg)
	content = strings.ReplaceAll(content, "{{ALLOWLIST_BLOCK}}", allowlistBlock)

	// Determine file path: container_network.conf
	dir := filepath.Join(m.hostsDir, cfg.Type)
	path := filepath.Join(dir, cfg.ConfigKey()+".conf")

	// Ensure directory exists
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}
	// Set ownership to 1000:1000
	os.Chown(dir, 1000, 1000)

	// Write atomically via temp file
	tmpPath := path + ".tmp"
	if err := os.WriteFile(tmpPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write temp file: %v", err)
	}

	if err := os.Rename(tmpPath, path); err != nil {
		os.Remove(tmpPath) // Clean up
		return fmt.Errorf("failed to rename temp file: %v", err)
	}
	// Set ownership to 1000:1000
	os.Chown(path, 1000, 1000)

	// Store config for status reporting
	m.configs[cfg.ConfigKey()] = cfg

	return nil
}

// generateAllowlistBlock generates the allowlist block for external type
func (m *CaddyManager) generateAllowlistBlock(cfg *CaddyConfig) string {
	// This function only applies to external type
	if cfg.Type != "external" {
		return ""
	}

	// No allowlist - simple reverse_proxy
	if len(cfg.Allowlist) == 0 {
		return fmt.Sprintf("\n    reverse_proxy %s", cfg.Upstream)
	}

	// Get resolved IPs from allowlist manager
	var ips []string
	if m.allowlistManager != nil {
		ips = m.allowlistManager.GetResolvedIPs(cfg.ConfigKey())
	}

	// If no resolved IPs yet, resolve now
	if len(ips) == 0 {
		if m.allowlistManager != nil {
			m.allowlistManager.Register(cfg)
			ips = m.allowlistManager.GetResolvedIPs(cfg.ConfigKey())
		}
	}

	// If still no IPs, return simple reverse_proxy (fallback)
	if len(ips) == 0 {
		log.Printf("Warning: no resolved IPs for allowlist in %s, falling back to open access", cfg.Network)
		return fmt.Sprintf("\n    reverse_proxy %s", cfg.Upstream)
	}

	// Generate allowlist block
	ipList := FormatAllowlistMatcher(ips)
	return fmt.Sprintf(`
    @allowed {
        remote_ip %s
    }

    handle @allowed {
        reverse_proxy %s
    }
    abort`, ipList, cfg.Upstream)
}

// generateAuthGroupsBlock generates the auth groups check block for external type
// Note: internal/cloudflare use generateHandleContent with route block for proper ordering
func (m *CaddyManager) generateAuthGroupsBlock(cfg *CaddyConfig) string {
	// Only for external type - internal/cloudflare use generateHandleContent
	if cfg.Type != "external" || len(cfg.AuthGroups) == 0 {
		return ""
	}

	// For external type, Caddy's default directive ordering works:
	// forward_auth runs first (from import auth), then respond checks the header
	groupPattern := strings.Join(cfg.AuthGroups, "|")
	return fmt.Sprintf(`
    @unauthorized_group not header_regexp Remote-Groups "(^|,)(%s)($|,)"
    respond @unauthorized_group "Forbidden - group not allowed" 403`, groupPattern)
}

// generateHandleContent generates content inside handle blocks for internal/cloudflare types
func (m *CaddyManager) generateHandleContent(cfg *CaddyConfig) string {
	// If auth_groups is set, we need to inline forward_auth in a route block
	// to ensure the group check happens AFTER forward_auth sets the header
	if len(cfg.AuthGroups) > 0 {
		groupPattern := strings.Join(cfg.AuthGroups, "|")
		return fmt.Sprintf(`        route {
            forward_auth {env.COMPOSE_PROJECT_NAME}-tinyauth-1:3000 {
                uri /api/auth/caddy
                copy_headers Remote-User Remote-Email Remote-Groups
            }
            @unauthorized_group not header_regexp Remote-Groups "(^|,)(%s)($|,)"
            respond @unauthorized_group "Forbidden - group not allowed" 403
            reverse_proxy %s
        }`, groupPattern, cfg.Upstream)
	}

	// No auth_groups - just reverse_proxy (auth import handles forward_auth if enabled)
	return fmt.Sprintf("        reverse_proxy %s", cfg.Upstream)
}

// RemoveConfig removes all Caddyfile configurations for a network
// Matches files ending with _network.conf (e.g., container_network.conf)
func (m *CaddyManager) RemoveConfig(network string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Remove from stored configs (all keys ending with _network)
	suffix := "_" + network
	for key := range m.configs {
		if strings.HasSuffix(key, suffix) {
			// Unregister from allowlist manager
			if m.allowlistManager != nil {
				m.allowlistManager.Unregister(key)
			}
			delete(m.configs, key)
		}
	}

	// Check all type directories for files matching *_network.conf
	types := []string{"internal", "external", "cloudflare"}
	fileSuffix := "_" + network + ".conf"

	for _, t := range types {
		dir := filepath.Join(m.hostsDir, t)
		entries, err := os.ReadDir(dir)
		if err != nil {
			continue
		}

		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}
			if strings.HasSuffix(entry.Name(), fileSuffix) {
				path := filepath.Join(dir, entry.Name())
				if err := os.Remove(path); err != nil {
					return fmt.Errorf("failed to remove %s: %v", path, err)
				}
			}
		}
	}

	return nil
}

// ListConfigs returns all configuration files
func (m *CaddyManager) ListConfigs() []ConfigInfo {
	m.mu.RLock()
	defer m.mu.RUnlock()

	var result []ConfigInfo
	types := []string{"internal", "external", "cloudflare"}

	for _, t := range types {
		dir := filepath.Join(m.hostsDir, t)
		entries, err := os.ReadDir(dir)
		if err != nil {
			continue
		}

		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}
			name := entry.Name()
			if !strings.HasSuffix(name, ".conf") {
				continue
			}
			// Skip example files
			if strings.HasSuffix(name, ".example") {
				continue
			}

			path := filepath.Join(dir, name)
			configKey := strings.TrimSuffix(name, ".conf")
			domains := extractDomainsFromConfig(path)

			// Parse container and network from filename (container_network)
			container := ""
			network := configKey
			if idx := strings.LastIndex(configKey, "_"); idx > 0 {
				container = configKey[:idx]
				network = configKey[idx+1:]
			}

			// Get allowlist entries if available
			var allowlist []string
			if m.allowlistManager != nil {
				allowlist = m.allowlistManager.GetEntries(configKey)
			}

			// Check if this is a managed (watcher-generated) config
			cfg, isManaged := m.configs[configKey]

			// Build config info
			info := ConfigInfo{
				Network:     network,
				Container:   container,
				Type:        t,
				Domains:     domains,
				Allowlist:   allowlist,
				Path:        path,
				TLS:         true, // defaults
				Compression: true,
				Header:      true,
				Managed:     isManaged,
			}

			// Use stored config for feature flags (managed configs only)
			if isManaged {
				info.Logging = cfg.Logging
				info.TLS = cfg.TLS
				info.Compression = cfg.Compression
				info.Header = cfg.Header
				info.Auth = cfg.Auth
			}

			result = append(result, info)
		}
	}

	return result
}

// extractDomainsFromConfig reads a config file and extracts domains
func extractDomainsFromConfig(path string) []string {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil
	}

	var domains []string
	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		// Look for lines starting with https://
		if strings.HasPrefix(line, "https://") {
			// Parse domains: "https://a.com, https://b.com {"
			line = strings.TrimSuffix(line, "{")
			line = strings.TrimSpace(line)
			parts := strings.Split(line, ",")
			for _, part := range parts {
				part = strings.TrimSpace(part)
				part = strings.TrimPrefix(part, "https://")
				if part != "" {
					domains = append(domains, part)
				}
			}
			// Continue to find all domain blocks in file
		}
	}

	return domains
}
