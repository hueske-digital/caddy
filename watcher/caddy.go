package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

// Embedded templates for Caddyfile generation
var templates = map[string]string{
	TypeExternal: `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
{{ALLOWLIST_BLOCK}}
}
`,
	TypeInternal: `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
    import internal

    handle @internal {
{{REVERSE_PROXY_BLOCK}}
    }
    abort
}
`,
	TypeCloudflare: `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
    import cloudflare

    handle @cloudflare {
{{REVERSE_PROXY_BLOCK}}
    }
    abort
}
`,
}

// CaddyManager manages Caddyfile configurations
type CaddyManager struct {
	hostsDir         string
	allowlistManager *AllowlistManager
	configs          map[string]*CaddyConfig // configKey (container_network) -> config
	mu               sync.RWMutex
}

// ConfigInfo holds information about a configuration file
type ConfigInfo struct {
	Network        string
	Container      string
	Type           string
	Domains        []string
	Allowlist      []string
	Logging        bool
	TLS            bool
	Compression    bool
	Header         bool
	Auth           bool
	AuthPaths      []string
	AuthURL        string
	SEO            bool
	WWWRedirect    bool
	Performance    bool
	Security       bool
	WordPress      bool
	TrustedProxies []string
	Path           string
	Managed        bool
}

// NewCaddyManager creates a new CaddyManager
func NewCaddyManager(hostsDir string, allowlistManager *AllowlistManager) *CaddyManager {
	return &CaddyManager{
		hostsDir:         hostsDir,
		allowlistManager: allowlistManager,
		configs:          make(map[string]*CaddyConfig),
	}
}

// resolveTrustedProxies resolves trusted proxies entries (hostnames/IPs) to IPs
func (m *CaddyManager) resolveTrustedProxies(entries []string) []string {
	if len(entries) == 0 || m.allowlistManager == nil {
		return nil
	}

	var allIPs []string
	seen := make(map[string]bool)

	for _, entry := range entries {
		ips := m.allowlistManager.resolveEntry(entry)
		for _, ip := range ips {
			if !seen[ip] {
				seen[ip] = true
				allIPs = append(allIPs, ip)
			}
		}
	}

	return allIPs
}

// generateReverseProxyBlock generates the reverse_proxy directive with optional trusted_proxies
// indent is the base indentation (e.g., "        " for 8 spaces)
// extraDirective is an optional additional directive inside the block (e.g., "header_up X-Real-IP ...")
func (m *CaddyManager) generateReverseProxyBlock(cfg *CaddyConfig, indent string, extraDirective string) string {
	resolvedProxies := m.resolveTrustedProxies(cfg.TrustedProxies)

	// Simple case: no extra directive and no trusted proxies
	if extraDirective == "" && len(resolvedProxies) == 0 {
		return indent + "reverse_proxy " + cfg.Upstream
	}

	// Need block format
	var lines []string
	lines = append(lines, indent+"reverse_proxy "+cfg.Upstream+" {")
	if extraDirective != "" {
		lines = append(lines, indent+"    "+extraDirective)
	}
	if len(resolvedProxies) > 0 {
		lines = append(lines, indent+"    trusted_proxies private_ranges "+strings.Join(resolvedProxies, " "))
	}
	lines = append(lines, indent+"}")

	return strings.Join(lines, "\n")
}

// WriteConfig writes a Caddyfile configuration for a service
func (m *CaddyManager) WriteConfig(cfg *CaddyConfig) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Check if type changed - delete old config file if so
	if oldCfg, exists := m.configs[cfg.ConfigKey()]; exists && oldCfg.Type != cfg.Type {
		oldPath := filepath.Join(m.hostsDir, oldCfg.Type, cfg.ConfigKey()+".conf")
		if err := os.Remove(oldPath); err == nil {
			log.Printf("Removed old config (type changed): %s/%s.conf", oldCfg.Type, cfg.ConfigKey())
		}
	}

	// Unregister from allowlist manager if allowlist was removed
	if oldCfg, exists := m.configs[cfg.ConfigKey()]; exists && len(oldCfg.Allowlist) > 0 && len(cfg.Allowlist) == 0 {
		if m.allowlistManager != nil {
			m.allowlistManager.Unregister(cfg.ConfigKey())
			log.Printf("Unregistered allowlist for %s (removed)", cfg.ConfigKey())
		}
	}

	// Get template for this type
	tmpl, ok := templates[cfg.Type]
	if !ok {
		return fmt.Errorf("unknown config type: %s", cfg.Type)
	}

	// Format domains for Caddy: https://a.com, https://b.com
	var formattedDomains []string
	for _, d := range cfg.Domains {
		formattedDomains = append(formattedDomains, "https://"+d)
	}

	// Replace placeholders
	content := tmpl
	content = strings.ReplaceAll(content, "{{NETWORK}}", cfg.Network)
	content = strings.ReplaceAll(content, "{{DOMAINS}}", strings.Join(formattedDomains, ", "))
	content = strings.ReplaceAll(content, "{{UPSTREAM}}", cfg.Upstream)

	// Generate imports block
	var imports []string
	if cfg.Logging {
		imports = append(imports, "    import logging")
	}
	if cfg.TLS {
		imports = append(imports, "    import tls")
	}
	if cfg.Compression {
		imports = append(imports, "    import compression")
	}
	if cfg.Header {
		imports = append(imports, "    import header")
	}
	// Auth handling: for external with allowlist, auth is inside handle block (added by generateAllowlistBlock)
	// For all other cases, auth is in imports
	if cfg.Auth && !(cfg.Type == TypeExternal && len(cfg.Allowlist) > 0) {
		if cfg.AuthURL != "" {
			// Custom auth server URL
			imports = append(imports, generateAuthBlock(cfg.AuthURL, cfg.AuthPaths))
		} else if len(cfg.AuthPaths) == 0 {
			// Protect entire site with local tinyauth
			imports = append(imports, "    import auth")
		} else {
			// Protect only specific paths with local tinyauth
			imports = append(imports, generateAuthBlock("", cfg.AuthPaths))
		}
	}
	if !cfg.SEO {
		imports = append(imports, "    import noindex")
	}
	if cfg.Performance {
		imports = append(imports, "    import performance")
	}
	if cfg.Security {
		imports = append(imports, "    import security")
	}
	if cfg.WordPress {
		imports = append(imports, "    import wordpress")
	}
	content = strings.ReplaceAll(content, "{{IMPORTS}}", strings.Join(imports, "\n"))

	// Handle allowlist placeholder (external type only)
	allowlistBlock := m.generateAllowlistBlock(cfg)
	content = strings.ReplaceAll(content, "{{ALLOWLIST_BLOCK}}", allowlistBlock)

	// Generate reverse_proxy block for internal and cloudflare types
	if cfg.Type == TypeInternal {
		rpBlock := m.generateReverseProxyBlock(cfg, "        ", "")
		content = strings.ReplaceAll(content, "{{REVERSE_PROXY_BLOCK}}", rpBlock)
	} else if cfg.Type == TypeCloudflare {
		rpBlock := m.generateReverseProxyBlock(cfg, "        ", "header_up X-Real-IP {header.CF-Connecting-IP}")
		content = strings.ReplaceAll(content, "{{REVERSE_PROXY_BLOCK}}", rpBlock)
	}

	// Append www redirect blocks if enabled
	if cfg.WWWRedirect {
		content += generateWWWRedirectBlocks(cfg.Domains)
	}

	// Determine file path: container_network.conf
	dir := filepath.Join(m.hostsDir, cfg.Type)
	path := filepath.Join(dir, cfg.ConfigKey()+".conf")

	// Ensure directory exists
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}
	// Set ownership to 1000:1000
	os.Chown(dir, 1000, 1000)

	// Write atomically via temp file
	tmpPath := path + ".tmp"
	if err := os.WriteFile(tmpPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write temp file: %v", err)
	}

	if err := os.Rename(tmpPath, path); err != nil {
		os.Remove(tmpPath) // Clean up
		return fmt.Errorf("failed to rename temp file: %v", err)
	}
	// Set ownership to 1000:1000
	os.Chown(path, 1000, 1000)

	// Store a copy of config for status reporting (not pointer to avoid mutation issues)
	cfgCopy := *cfg
	m.configs[cfg.ConfigKey()] = &cfgCopy

	return nil
}

// generateAllowlistBlock generates the allowlist block for external type
func (m *CaddyManager) generateAllowlistBlock(cfg *CaddyConfig) string {
	// This function only applies to external type
	if cfg.Type != TypeExternal {
		return ""
	}

	// Resolve trusted proxies if set
	resolvedProxies := m.resolveTrustedProxies(cfg.TrustedProxies)
	trustedProxiesLine := ""
	if len(resolvedProxies) > 0 {
		trustedProxiesLine = "\n            trusted_proxies private_ranges " + strings.Join(resolvedProxies, " ")
	}

	// No allowlist - simple or block reverse_proxy
	if len(cfg.Allowlist) == 0 {
		if len(resolvedProxies) == 0 {
			return fmt.Sprintf(`
    reverse_proxy %s`, cfg.Upstream)
		}
		return fmt.Sprintf(`
    reverse_proxy %s {%s
    }`, cfg.Upstream, trustedProxiesLine)
	}

	// Get resolved IPs from allowlist manager
	var ips []string
	if m.allowlistManager != nil {
		ips = m.allowlistManager.GetResolvedIPs(cfg.ConfigKey())
	}

	// If no resolved IPs yet, resolve now
	if len(ips) == 0 {
		if m.allowlistManager != nil {
			m.allowlistManager.Register(cfg)
			ips = m.allowlistManager.GetResolvedIPs(cfg.ConfigKey())
		}
	}

	// Generate auth block if needed (for external with allowlist, auth goes inside handle)
	authBlock := ""
	if cfg.Auth {
		authBlock = generateAuthBlock(cfg.AuthURL, cfg.AuthPaths) + "\n"
	}

	// Format reverse_proxy with optional trusted_proxies
	reverseProxyBlock := fmt.Sprintf("reverse_proxy %s", cfg.Upstream)
	if len(resolvedProxies) > 0 {
		reverseProxyBlock = fmt.Sprintf(`reverse_proxy %s {
            trusted_proxies private_ranges %s
        }`, cfg.Upstream, strings.Join(resolvedProxies, " "))
	}

	// Generate allowlist block (private_ranges always allowed for internal access)
	// Even if DNS fails, we still restrict to private_ranges - never fall back to open access
	if len(ips) == 0 {
		log.Printf("Warning: no resolved IPs for allowlist in %s, restricting to private_ranges only", cfg.ConfigKey())
		return fmt.Sprintf(`
    @allowed {
        remote_ip private_ranges
    }

    handle @allowed {
%s        %s
    }
    abort`, authBlock, reverseProxyBlock)
	}

	ipList := FormatAllowlistMatcher(ips)
	return fmt.Sprintf(`
    @allowed {
        remote_ip private_ranges %s
    }

    handle @allowed {
%s        %s
    }
    abort`, ipList, authBlock, reverseProxyBlock)
}

// generateWWWRedirectBlocks generates separate site blocks for www to non-www redirects
func generateWWWRedirectBlocks(domains []string) string {
	var blocks []string
	for _, domain := range domains {
		block := fmt.Sprintf(`
# www redirect
https://www.%s {
    import tls
    redir https://%s{uri} permanent
}`, domain, domain)
		blocks = append(blocks, block)
	}
	return strings.Join(blocks, "\n")
}

// generateAuthBlock generates forward_auth directive
// If authURL is empty, uses local tinyauth container
// If paths is empty, protects entire site
func generateAuthBlock(authURL string, paths []string) string {
	// Determine auth server
	authServer := "{env.COMPOSE_PROJECT_NAME}-tinyauth-1:3000"
	headerUp := ""

	if authURL != "" {
		authServer = authURL
		// External HTTPS auth servers need correct Host header
		if strings.HasPrefix(authURL, "https://") {
			headerUp = "\n        header_up Host {http.reverse_proxy.upstream.hostport}"
		}
	}

	// Full site auth (no paths)
	if len(paths) == 0 {
		return fmt.Sprintf(`    forward_auth %s {
        uri /api/auth/caddy
        copy_headers Remote-User Remote-Email Remote-Groups%s
    }`, authServer, headerUp)
	}

	// Path-based auth
	pathList := strings.Join(paths, " ")
	return fmt.Sprintf(`    @auth-paths path %s
    forward_auth @auth-paths %s {
        uri /api/auth/caddy
        copy_headers Remote-User Remote-Email Remote-Groups%s
    }`, pathList, authServer, headerUp)
}

// RemoveConfig removes all Caddyfile configurations for a network
// Matches files ending with _network.conf (e.g., container_network.conf)
func (m *CaddyManager) RemoveConfig(network string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Remove from stored configs (all keys ending with _network)
	suffix := "_" + network
	for key := range m.configs {
		if strings.HasSuffix(key, suffix) {
			// Unregister from allowlist manager
			if m.allowlistManager != nil {
				m.allowlistManager.Unregister(key)
			}
			delete(m.configs, key)
		}
	}

	// Check all type directories for files matching *_network.conf
	types := ValidTypes
	fileSuffix := "_" + network + ".conf"

	for _, t := range types {
		dir := filepath.Join(m.hostsDir, t)
		entries, err := os.ReadDir(dir)
		if err != nil {
			continue
		}

		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}
			if strings.HasSuffix(entry.Name(), fileSuffix) {
				path := filepath.Join(dir, entry.Name())
				if err := os.Remove(path); err != nil {
					return fmt.Errorf("failed to remove %s: %v", path, err)
				}
			}
		}
	}

	return nil
}

// ListConfigs returns all configuration files
func (m *CaddyManager) ListConfigs() []ConfigInfo {
	m.mu.RLock()
	defer m.mu.RUnlock()

	var result []ConfigInfo
	types := ValidTypes

	for _, t := range types {
		dir := filepath.Join(m.hostsDir, t)
		entries, err := os.ReadDir(dir)
		if err != nil {
			continue
		}

		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}
			name := entry.Name()
			if !strings.HasSuffix(name, ".conf") {
				continue
			}
			// Skip example files
			if strings.HasSuffix(name, ".example") {
				continue
			}

			path := filepath.Join(dir, name)
			configKey := strings.TrimSuffix(name, ".conf")
			domains := extractDomainsFromConfig(path)

			// Parse container and network from filename (container_network)
			container := ""
			network := configKey
			if idx := strings.LastIndex(configKey, "_"); idx > 0 {
				container = configKey[:idx]
				network = configKey[idx+1:]
			}

			// Check if this is a managed (watcher-generated) config
			cfg, isManaged := m.configs[configKey]

			// Get allowlist from stored config (most accurate source)
			var allowlist []string
			if isManaged && len(cfg.Allowlist) > 0 {
				allowlist = cfg.Allowlist
			}

			// Build config info
			info := ConfigInfo{
				Network:   network,
				Container: container,
				Type:      t,
				Domains:   domains,
				Allowlist: allowlist,
				Path:      path,
				Managed:   isManaged,
			}

			// Use stored config for feature flags (managed configs only)
			if isManaged {
				info.Logging = cfg.Logging
				info.TLS = cfg.TLS
				info.Compression = cfg.Compression
				info.Header = cfg.Header
				info.Auth = cfg.Auth
				info.AuthPaths = cfg.AuthPaths
				info.AuthURL = cfg.AuthURL
				info.SEO = cfg.SEO
				info.WWWRedirect = cfg.WWWRedirect
				info.Performance = cfg.Performance
				info.Security = cfg.Security
				info.WordPress = cfg.WordPress
				info.TrustedProxies = cfg.TrustedProxies
			} else {
				// Parse imports from manual config file
				content, err := os.ReadFile(path)
				if err == nil {
					parseImportsFromContent(string(content), &info)
				}
			}

			result = append(result, info)
		}
	}

	return result
}

// parseImportsFromContent parses import statements from config content
// and sets the corresponding flags in ConfigInfo
func parseImportsFromContent(content string, info *ConfigInfo) {
	// Default: SEO is true (indexable) unless noindex is imported
	info.SEO = true

	lines := strings.Split(content, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)

		// Parse import statements
		if strings.HasPrefix(line, "import ") {
			importName := strings.TrimPrefix(line, "import ")
			importName = strings.TrimSpace(importName)

			switch importName {
			case "logging":
				info.Logging = true
			case "tls":
				info.TLS = true
			case "compression":
				info.Compression = true
			case "header":
				info.Header = true
			case "noindex":
				info.SEO = false
			case "performance":
				info.Performance = true
			case "security":
				info.Security = true
			case "wordpress":
				info.WordPress = true
			case "auth":
				info.Auth = true
			}
		}

		// Parse trusted_proxies directive
		// Format: trusted_proxies private_ranges 1.2.3.4 5.6.7.8
		if strings.HasPrefix(line, "trusted_proxies") {
			parts := strings.Fields(line)
			// Skip "trusted_proxies" and optionally "private_ranges"
			var proxies []string
			for i := 1; i < len(parts); i++ {
				if parts[i] != "private_ranges" {
					proxies = append(proxies, parts[i])
				}
			}
			if len(proxies) > 0 {
				info.TrustedProxies = proxies
			}
		}
	}

	// Check for www redirect (separate server block with redir)
	// Pattern: www.domain { ... redir https://domain ... }
	if strings.Contains(content, "www.") && strings.Contains(content, "redir ") && strings.Contains(content, "permanent") {
		info.WWWRedirect = true
	}
}

// extractDomainsFromConfig reads a config file and extracts domains
func extractDomainsFromConfig(path string) []string {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil
	}

	var domains []string
	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		// Look for lines starting with https://
		if strings.HasPrefix(line, "https://") {
			// Parse domains: "https://a.com, https://b.com {"
			line = strings.TrimSuffix(line, "{")
			line = strings.TrimSpace(line)
			parts := strings.Split(line, ",")
			for _, part := range parts {
				part = strings.TrimSpace(part)
				part = strings.TrimPrefix(part, "https://")
				if part != "" {
					domains = append(domains, part)
				}
			}
			// Continue to find all domain blocks in file
		}
	}

	return domains
}

// Wildcard certificate template
var wildcardTemplate = `# Wildcard certificate for *.{{DOMAIN}}
# Auto-generated by watcher - do not edit manually
# Services using subdomains of {{DOMAIN}} will automatically use this certificate

*.{{DOMAIN}} {
    import tls
    abort
}
`

// WriteWildcardConfigs generates wildcard certificate configs for the specified domains
func (m *CaddyManager) WriteWildcardConfigs(domains []string) error {
	if len(domains) == 0 {
		return nil
	}

	// Wildcards go into hosts root directory (global configs like base.conf)
	dir := m.hostsDir

	// Ensure directory exists
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}
	os.Chown(dir, 1000, 1000)

	for _, domain := range domains {
		filename := fmt.Sprintf("wildcard.%s.conf", domain)
		path := filepath.Join(dir, filename)

		// Generate content from template
		content := wildcardTemplate
		content = strings.ReplaceAll(content, "{{DOMAIN}}", domain)

		// Write atomically via temp file
		tmpPath := path + ".tmp"
		if err := os.WriteFile(tmpPath, []byte(content), 0644); err != nil {
			return fmt.Errorf("failed to write temp file: %v", err)
		}

		if err := os.Rename(tmpPath, path); err != nil {
			os.Remove(tmpPath)
			return fmt.Errorf("failed to rename temp file: %v", err)
		}
		os.Chown(path, 1000, 1000)

		log.Printf("Generated wildcard config: wildcard.%s.conf", domain)
	}

	return nil
}

// GetWildcardDomains returns the list of configured wildcard domains from config files
func (m *CaddyManager) GetWildcardDomains() []string {
	m.mu.RLock()
	defer m.mu.RUnlock()

	var domains []string

	entries, err := os.ReadDir(m.hostsDir)
	if err != nil {
		return domains
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		// Match wildcard.*.conf pattern
		if strings.HasPrefix(name, "wildcard.") && strings.HasSuffix(name, ".conf") {
			// Extract domain: wildcard.example.com.conf -> example.com
			domain := strings.TrimPrefix(name, "wildcard.")
			domain = strings.TrimSuffix(domain, ".conf")
			domains = append(domains, domain)
		}
	}

	return domains
}
