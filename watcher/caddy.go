package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

// Embedded templates for Caddyfile generation
var templates = map[string]string{
	TypeExternal: `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
{{ALLOWLIST_BLOCK}}
}
`,
	TypeInternal: `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
    import internal

    handle @internal {
        reverse_proxy {{UPSTREAM}}
    }
    abort
}
`,
	TypeCloudflare: `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
    import cloudflare

    handle @cloudflare {
        reverse_proxy {{UPSTREAM}} {
            header_up X-Real-IP {header.CF-Connecting-IP}
        }
    }
    abort
}
`,
}

// CaddyManager manages Caddyfile configurations
type CaddyManager struct {
	hostsDir         string
	allowlistManager *AllowlistManager
	configs          map[string]*CaddyConfig // configKey (container_network) -> config
	mu               sync.RWMutex
}

// ConfigInfo holds information about a configuration file
type ConfigInfo struct {
	Network     string
	Container   string
	Type        string
	Domains     []string
	Allowlist   []string
	Logging     bool
	TLS         bool
	Compression bool
	Header      bool
	Auth        bool
	AuthPaths   []string
	SEO         bool
	WWWRedirect bool
	Performance bool
	Security    bool
	WordPress   bool
	Path        string
	Managed     bool
}

// NewCaddyManager creates a new CaddyManager
func NewCaddyManager(hostsDir string, allowlistManager *AllowlistManager) *CaddyManager {
	return &CaddyManager{
		hostsDir:         hostsDir,
		allowlistManager: allowlistManager,
		configs:          make(map[string]*CaddyConfig),
	}
}

// WriteConfig writes a Caddyfile configuration for a service
func (m *CaddyManager) WriteConfig(cfg *CaddyConfig) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Get template for this type
	tmpl, ok := templates[cfg.Type]
	if !ok {
		return fmt.Errorf("unknown config type: %s", cfg.Type)
	}

	// Format domains for Caddy: https://a.com, https://b.com
	var formattedDomains []string
	for _, d := range cfg.Domains {
		formattedDomains = append(formattedDomains, "https://"+d)
	}

	// Replace placeholders
	content := tmpl
	content = strings.ReplaceAll(content, "{{NETWORK}}", cfg.Network)
	content = strings.ReplaceAll(content, "{{DOMAINS}}", strings.Join(formattedDomains, ", "))
	content = strings.ReplaceAll(content, "{{UPSTREAM}}", cfg.Upstream)

	// Generate imports block
	var imports []string
	if cfg.Logging {
		imports = append(imports, "    import logging")
	}
	if cfg.TLS {
		imports = append(imports, "    import tls")
	}
	if cfg.Compression {
		imports = append(imports, "    import compression")
	}
	if cfg.Header {
		imports = append(imports, "    import header")
	}
	if cfg.Auth {
		if len(cfg.AuthPaths) == 0 {
			// Protect entire site
			imports = append(imports, "    import auth")
		} else {
			// Protect only specific paths
			imports = append(imports, generatePathBasedAuth(cfg.AuthPaths))
		}
	}
	if cfg.SEO {
		imports = append(imports, "    import seo")
	}
	if cfg.Performance {
		imports = append(imports, "    import performance")
	}
	if cfg.Security {
		imports = append(imports, "    import security")
	}
	if cfg.WordPress {
		imports = append(imports, "    import wordpress")
	}
	content = strings.ReplaceAll(content, "{{IMPORTS}}", strings.Join(imports, "\n"))

	// Handle allowlist placeholder (external type only)
	allowlistBlock := m.generateAllowlistBlock(cfg)
	content = strings.ReplaceAll(content, "{{ALLOWLIST_BLOCK}}", allowlistBlock)

	// Append www redirect blocks if enabled
	if cfg.WWWRedirect {
		content += generateWWWRedirectBlocks(cfg.Domains)
	}

	// Determine file path: container_network.conf
	dir := filepath.Join(m.hostsDir, cfg.Type)
	path := filepath.Join(dir, cfg.ConfigKey()+".conf")

	// Ensure directory exists
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}
	// Set ownership to 1000:1000
	os.Chown(dir, 1000, 1000)

	// Write atomically via temp file
	tmpPath := path + ".tmp"
	if err := os.WriteFile(tmpPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write temp file: %v", err)
	}

	if err := os.Rename(tmpPath, path); err != nil {
		os.Remove(tmpPath) // Clean up
		return fmt.Errorf("failed to rename temp file: %v", err)
	}
	// Set ownership to 1000:1000
	os.Chown(path, 1000, 1000)

	// Store config for status reporting
	m.configs[cfg.ConfigKey()] = cfg

	return nil
}

// generateAllowlistBlock generates the allowlist block for external type
func (m *CaddyManager) generateAllowlistBlock(cfg *CaddyConfig) string {
	// This function only applies to external type
	if cfg.Type != TypeExternal {
		return ""
	}

	// No allowlist - simple reverse_proxy
	if len(cfg.Allowlist) == 0 {
		return fmt.Sprintf(`
    reverse_proxy %s`, cfg.Upstream)
	}

	// Get resolved IPs from allowlist manager
	var ips []string
	if m.allowlistManager != nil {
		ips = m.allowlistManager.GetResolvedIPs(cfg.ConfigKey())
	}

	// If no resolved IPs yet, resolve now
	if len(ips) == 0 {
		if m.allowlistManager != nil {
			m.allowlistManager.Register(cfg)
			ips = m.allowlistManager.GetResolvedIPs(cfg.ConfigKey())
		}
	}

	// If still no IPs, return simple reverse_proxy (fallback)
	if len(ips) == 0 {
		log.Printf("Warning: no resolved IPs for allowlist in %s, falling back to open access", cfg.Network)
		return fmt.Sprintf(`
    reverse_proxy %s`, cfg.Upstream)
	}

	// Generate allowlist block
	ipList := FormatAllowlistMatcher(ips)
	return fmt.Sprintf(`
    @allowed {
        remote_ip %s
    }

    handle @allowed {
        reverse_proxy %s
    }
    abort`, ipList, cfg.Upstream)
}

// generateWWWRedirectBlocks generates separate site blocks for www to non-www redirects
func generateWWWRedirectBlocks(domains []string) string {
	var blocks []string
	for _, domain := range domains {
		block := fmt.Sprintf(`
# www redirect
https://www.%s {
    import tls
    redir https://%s{uri} permanent
}`, domain, domain)
		blocks = append(blocks, block)
	}
	return strings.Join(blocks, "\n")
}

// generatePathBasedAuth generates forward_auth for specific paths only
func generatePathBasedAuth(paths []string) string {
	pathList := strings.Join(paths, " ")
	return fmt.Sprintf(`    @auth-paths path %s
    forward_auth @auth-paths {env.COMPOSE_PROJECT_NAME}-tinyauth-1:3000 {
        uri /api/auth/caddy
        copy_headers Remote-User Remote-Email Remote-Groups
    }`, pathList)
}

// RemoveConfig removes all Caddyfile configurations for a network
// Matches files ending with _network.conf (e.g., container_network.conf)
func (m *CaddyManager) RemoveConfig(network string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Remove from stored configs (all keys ending with _network)
	suffix := "_" + network
	for key := range m.configs {
		if strings.HasSuffix(key, suffix) {
			// Unregister from allowlist manager
			if m.allowlistManager != nil {
				m.allowlistManager.Unregister(key)
			}
			delete(m.configs, key)
		}
	}

	// Check all type directories for files matching *_network.conf
	types := ValidTypes
	fileSuffix := "_" + network + ".conf"

	for _, t := range types {
		dir := filepath.Join(m.hostsDir, t)
		entries, err := os.ReadDir(dir)
		if err != nil {
			continue
		}

		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}
			if strings.HasSuffix(entry.Name(), fileSuffix) {
				path := filepath.Join(dir, entry.Name())
				if err := os.Remove(path); err != nil {
					return fmt.Errorf("failed to remove %s: %v", path, err)
				}
			}
		}
	}

	return nil
}

// ListConfigs returns all configuration files
func (m *CaddyManager) ListConfigs() []ConfigInfo {
	m.mu.RLock()
	defer m.mu.RUnlock()

	var result []ConfigInfo
	types := ValidTypes

	for _, t := range types {
		dir := filepath.Join(m.hostsDir, t)
		entries, err := os.ReadDir(dir)
		if err != nil {
			continue
		}

		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}
			name := entry.Name()
			if !strings.HasSuffix(name, ".conf") {
				continue
			}
			// Skip example files
			if strings.HasSuffix(name, ".example") {
				continue
			}

			path := filepath.Join(dir, name)
			configKey := strings.TrimSuffix(name, ".conf")
			domains := extractDomainsFromConfig(path)

			// Parse container and network from filename (container_network)
			container := ""
			network := configKey
			if idx := strings.LastIndex(configKey, "_"); idx > 0 {
				container = configKey[:idx]
				network = configKey[idx+1:]
			}

			// Get allowlist entries if available
			var allowlist []string
			if m.allowlistManager != nil {
				allowlist = m.allowlistManager.GetEntries(configKey)
			}

			// Check if this is a managed (watcher-generated) config
			cfg, isManaged := m.configs[configKey]

			// Build config info
			info := ConfigInfo{
				Network:     network,
				Container:   container,
				Type:        t,
				Domains:     domains,
				Allowlist:   allowlist,
				Path:        path,
				TLS:         true, // defaults
				Compression: true,
				Header:      true,
				Performance: true,
				Security:    true,
				Managed:     isManaged,
			}

			// Use stored config for feature flags (managed configs only)
			if isManaged {
				info.Logging = cfg.Logging
				info.TLS = cfg.TLS
				info.Compression = cfg.Compression
				info.Header = cfg.Header
				info.Auth = cfg.Auth
				info.AuthPaths = cfg.AuthPaths
				info.SEO = cfg.SEO
				info.WWWRedirect = cfg.WWWRedirect
				info.Performance = cfg.Performance
				info.Security = cfg.Security
				info.WordPress = cfg.WordPress
			}

			result = append(result, info)
		}
	}

	return result
}

// extractDomainsFromConfig reads a config file and extracts domains
func extractDomainsFromConfig(path string) []string {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil
	}

	var domains []string
	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		// Look for lines starting with https://
		if strings.HasPrefix(line, "https://") {
			// Parse domains: "https://a.com, https://b.com {"
			line = strings.TrimSuffix(line, "{")
			line = strings.TrimSpace(line)
			parts := strings.Split(line, ",")
			for _, part := range parts {
				part = strings.TrimSpace(part)
				part = strings.TrimPrefix(part, "https://")
				if part != "" {
					domains = append(domains, part)
				}
			}
			// Continue to find all domain blocks in file
		}
	}

	return domains
}
