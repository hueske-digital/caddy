package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

// Embedded templates for Caddyfile generation
var templates = map[string]string{
	TypeExternal: `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
{{ALLOWLIST_BLOCK}}
}
`,
	TypeInternal: `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
    import internal

    handle @internal {
        reverse_proxy {{UPSTREAM}}
    }
    abort
}
`,
	TypeCloudflare: `# {{NETWORK}} - auto-generated by watcher

{{DOMAINS}} {
{{IMPORTS}}
    import cloudflare

    handle @cloudflare {
        reverse_proxy {{UPSTREAM}} {
            header_up X-Real-IP {header.CF-Connecting-IP}
        }
    }
    abort
}
`,
}

// CaddyManager manages Caddyfile configurations
type CaddyManager struct {
	hostsDir         string
	allowlistManager *AllowlistManager
	configs          map[string]*CaddyConfig // configKey (container_network) -> config
	mu               sync.RWMutex
}

// ConfigInfo holds information about a configuration file
type ConfigInfo struct {
	Network     string
	Container   string
	Type        string
	Domains     []string
	Allowlist   []string
	Logging     bool
	TLS         bool
	Compression bool
	Header      bool
	Auth        bool
	AuthPaths   []string
	AuthURL     string
	SEO         bool
	WWWRedirect bool
	Performance bool
	Security    bool
	WordPress   bool
	Path        string
	Managed     bool
}

// NewCaddyManager creates a new CaddyManager
func NewCaddyManager(hostsDir string, allowlistManager *AllowlistManager) *CaddyManager {
	return &CaddyManager{
		hostsDir:         hostsDir,
		allowlistManager: allowlistManager,
		configs:          make(map[string]*CaddyConfig),
	}
}

// WriteConfig writes a Caddyfile configuration for a service
func (m *CaddyManager) WriteConfig(cfg *CaddyConfig) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Check if type changed - delete old config file if so
	if oldCfg, exists := m.configs[cfg.ConfigKey()]; exists && oldCfg.Type != cfg.Type {
		oldPath := filepath.Join(m.hostsDir, oldCfg.Type, cfg.ConfigKey()+".conf")
		if err := os.Remove(oldPath); err == nil {
			log.Printf("Removed old config (type changed): %s/%s.conf", oldCfg.Type, cfg.ConfigKey())
		}
	}

	// Unregister from allowlist manager if allowlist was removed
	if oldCfg, exists := m.configs[cfg.ConfigKey()]; exists && len(oldCfg.Allowlist) > 0 && len(cfg.Allowlist) == 0 {
		if m.allowlistManager != nil {
			m.allowlistManager.Unregister(cfg.ConfigKey())
			log.Printf("Unregistered allowlist for %s (removed)", cfg.ConfigKey())
		}
	}

	// Get template for this type
	tmpl, ok := templates[cfg.Type]
	if !ok {
		return fmt.Errorf("unknown config type: %s", cfg.Type)
	}

	// Format domains for Caddy: https://a.com, https://b.com
	var formattedDomains []string
	for _, d := range cfg.Domains {
		formattedDomains = append(formattedDomains, "https://"+d)
	}

	// Replace placeholders
	content := tmpl
	content = strings.ReplaceAll(content, "{{NETWORK}}", cfg.Network)
	content = strings.ReplaceAll(content, "{{DOMAINS}}", strings.Join(formattedDomains, ", "))
	content = strings.ReplaceAll(content, "{{UPSTREAM}}", cfg.Upstream)

	// Generate imports block
	var imports []string
	if cfg.Logging {
		imports = append(imports, "    import logging")
	}
	if cfg.TLS {
		imports = append(imports, "    import tls")
	}
	if cfg.Compression {
		imports = append(imports, "    import compression")
	}
	if cfg.Header {
		imports = append(imports, "    import header")
	}
	// Auth handling: for external with allowlist, auth is inside handle block (added by generateAllowlistBlock)
	// For all other cases, auth is in imports
	if cfg.Auth && !(cfg.Type == TypeExternal && len(cfg.Allowlist) > 0) {
		if cfg.AuthURL != "" {
			// Custom auth server URL
			imports = append(imports, generateAuthBlock(cfg.AuthURL, cfg.AuthPaths))
		} else if len(cfg.AuthPaths) == 0 {
			// Protect entire site with local tinyauth
			imports = append(imports, "    import auth")
		} else {
			// Protect only specific paths with local tinyauth
			imports = append(imports, generateAuthBlock("", cfg.AuthPaths))
		}
	}
	if !cfg.SEO {
		imports = append(imports, "    import noindex")
	}
	if cfg.Performance {
		imports = append(imports, "    import performance")
	}
	if cfg.Security {
		imports = append(imports, "    import security")
	}
	if cfg.WordPress {
		imports = append(imports, "    import wordpress")
	}
	content = strings.ReplaceAll(content, "{{IMPORTS}}", strings.Join(imports, "\n"))

	// Handle allowlist placeholder (external type only)
	allowlistBlock := m.generateAllowlistBlock(cfg)
	content = strings.ReplaceAll(content, "{{ALLOWLIST_BLOCK}}", allowlistBlock)

	// Append www redirect blocks if enabled
	if cfg.WWWRedirect {
		content += generateWWWRedirectBlocks(cfg.Domains)
	}

	// Determine file path: container_network.conf
	dir := filepath.Join(m.hostsDir, cfg.Type)
	path := filepath.Join(dir, cfg.ConfigKey()+".conf")

	// Ensure directory exists
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}
	// Set ownership to 1000:1000
	os.Chown(dir, 1000, 1000)

	// Write atomically via temp file
	tmpPath := path + ".tmp"
	if err := os.WriteFile(tmpPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write temp file: %v", err)
	}

	if err := os.Rename(tmpPath, path); err != nil {
		os.Remove(tmpPath) // Clean up
		return fmt.Errorf("failed to rename temp file: %v", err)
	}
	// Set ownership to 1000:1000
	os.Chown(path, 1000, 1000)

	// Store a copy of config for status reporting (not pointer to avoid mutation issues)
	cfgCopy := *cfg
	m.configs[cfg.ConfigKey()] = &cfgCopy

	return nil
}

// generateAllowlistBlock generates the allowlist block for external type
func (m *CaddyManager) generateAllowlistBlock(cfg *CaddyConfig) string {
	// This function only applies to external type
	if cfg.Type != TypeExternal {
		return ""
	}

	// No allowlist - simple reverse_proxy
	if len(cfg.Allowlist) == 0 {
		return fmt.Sprintf(`
    reverse_proxy %s`, cfg.Upstream)
	}

	// Get resolved IPs from allowlist manager
	var ips []string
	if m.allowlistManager != nil {
		ips = m.allowlistManager.GetResolvedIPs(cfg.ConfigKey())
	}

	// If no resolved IPs yet, resolve now
	if len(ips) == 0 {
		if m.allowlistManager != nil {
			m.allowlistManager.Register(cfg)
			ips = m.allowlistManager.GetResolvedIPs(cfg.ConfigKey())
		}
	}

	// Generate auth block if needed (for external with allowlist, auth goes inside handle)
	authBlock := ""
	if cfg.Auth {
		authBlock = generateAuthBlock(cfg.AuthURL, cfg.AuthPaths) + "\n"
	}

	// Generate allowlist block (private_ranges always allowed for internal access)
	// Even if DNS fails, we still restrict to private_ranges - never fall back to open access
	if len(ips) == 0 {
		log.Printf("Warning: no resolved IPs for allowlist in %s, restricting to private_ranges only", cfg.ConfigKey())
		return fmt.Sprintf(`
    @allowed {
        remote_ip private_ranges
    }

    handle @allowed {
%s        reverse_proxy %s
    }
    abort`, authBlock, cfg.Upstream)
	}

	ipList := FormatAllowlistMatcher(ips)
	return fmt.Sprintf(`
    @allowed {
        remote_ip private_ranges %s
    }

    handle @allowed {
%s        reverse_proxy %s
    }
    abort`, ipList, authBlock, cfg.Upstream)
}

// generateWWWRedirectBlocks generates separate site blocks for www to non-www redirects
func generateWWWRedirectBlocks(domains []string) string {
	var blocks []string
	for _, domain := range domains {
		block := fmt.Sprintf(`
# www redirect
https://www.%s {
    import tls
    redir https://%s{uri} permanent
}`, domain, domain)
		blocks = append(blocks, block)
	}
	return strings.Join(blocks, "\n")
}

// generateAuthBlock generates forward_auth directive
// If authURL is empty, uses local tinyauth container
// If paths is empty, protects entire site
func generateAuthBlock(authURL string, paths []string) string {
	// Determine auth server
	authServer := "{env.COMPOSE_PROJECT_NAME}-tinyauth-1:3000"
	headerUp := ""

	if authURL != "" {
		authServer = authURL
		// External HTTPS auth servers need correct Host header
		if strings.HasPrefix(authURL, "https://") {
			headerUp = "\n        header_up Host {http.reverse_proxy.upstream.hostport}"
		}
	}

	// Full site auth (no paths)
	if len(paths) == 0 {
		return fmt.Sprintf(`    forward_auth %s {
        uri /api/auth/caddy
        copy_headers Remote-User Remote-Email Remote-Groups%s
    }`, authServer, headerUp)
	}

	// Path-based auth
	pathList := strings.Join(paths, " ")
	return fmt.Sprintf(`    @auth-paths path %s
    forward_auth @auth-paths %s {
        uri /api/auth/caddy
        copy_headers Remote-User Remote-Email Remote-Groups%s
    }`, pathList, authServer, headerUp)
}

// RemoveConfig removes all Caddyfile configurations for a network
// Matches files ending with _network.conf (e.g., container_network.conf)
func (m *CaddyManager) RemoveConfig(network string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Remove from stored configs (all keys ending with _network)
	suffix := "_" + network
	for key := range m.configs {
		if strings.HasSuffix(key, suffix) {
			// Unregister from allowlist manager
			if m.allowlistManager != nil {
				m.allowlistManager.Unregister(key)
			}
			delete(m.configs, key)
		}
	}

	// Check all type directories for files matching *_network.conf
	types := ValidTypes
	fileSuffix := "_" + network + ".conf"

	for _, t := range types {
		dir := filepath.Join(m.hostsDir, t)
		entries, err := os.ReadDir(dir)
		if err != nil {
			continue
		}

		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}
			if strings.HasSuffix(entry.Name(), fileSuffix) {
				path := filepath.Join(dir, entry.Name())
				if err := os.Remove(path); err != nil {
					return fmt.Errorf("failed to remove %s: %v", path, err)
				}
			}
		}
	}

	return nil
}

// ListConfigs returns all configuration files
func (m *CaddyManager) ListConfigs() []ConfigInfo {
	m.mu.RLock()
	defer m.mu.RUnlock()

	var result []ConfigInfo
	types := ValidTypes

	for _, t := range types {
		dir := filepath.Join(m.hostsDir, t)
		entries, err := os.ReadDir(dir)
		if err != nil {
			continue
		}

		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}
			name := entry.Name()
			if !strings.HasSuffix(name, ".conf") {
				continue
			}
			// Skip example files
			if strings.HasSuffix(name, ".example") {
				continue
			}

			path := filepath.Join(dir, name)
			configKey := strings.TrimSuffix(name, ".conf")
			domains := extractDomainsFromConfig(path)

			// Parse container and network from filename (container_network)
			container := ""
			network := configKey
			if idx := strings.LastIndex(configKey, "_"); idx > 0 {
				container = configKey[:idx]
				network = configKey[idx+1:]
			}

			// Check if this is a managed (watcher-generated) config
			cfg, isManaged := m.configs[configKey]

			// Get allowlist from stored config (most accurate source)
			var allowlist []string
			if isManaged && len(cfg.Allowlist) > 0 {
				allowlist = cfg.Allowlist
			}

			// Build config info
			info := ConfigInfo{
				Network:     network,
				Container:   container,
				Type:        t,
				Domains:     domains,
				Allowlist:   allowlist,
				Path:        path,
				TLS:         true, // defaults
				Compression: true,
				Header:      true,
				Performance: true,
				Security:    true,
				Managed:     isManaged,
			}

			// Use stored config for feature flags (managed configs only)
			if isManaged {
				info.Logging = cfg.Logging
				info.TLS = cfg.TLS
				info.Compression = cfg.Compression
				info.Header = cfg.Header
				info.Auth = cfg.Auth
				info.AuthPaths = cfg.AuthPaths
				info.AuthURL = cfg.AuthURL
				info.SEO = cfg.SEO
				info.WWWRedirect = cfg.WWWRedirect
				info.Performance = cfg.Performance
				info.Security = cfg.Security
				info.WordPress = cfg.WordPress
			}

			result = append(result, info)
		}
	}

	return result
}

// extractDomainsFromConfig reads a config file and extracts domains
func extractDomainsFromConfig(path string) []string {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil
	}

	var domains []string
	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		// Look for lines starting with https://
		if strings.HasPrefix(line, "https://") {
			// Parse domains: "https://a.com, https://b.com {"
			line = strings.TrimSuffix(line, "{")
			line = strings.TrimSpace(line)
			parts := strings.Split(line, ",")
			for _, part := range parts {
				part = strings.TrimSpace(part)
				part = strings.TrimPrefix(part, "https://")
				if part != "" {
					domains = append(domains, part)
				}
			}
			// Continue to find all domain blocks in file
		}
	}

	return domains
}

// Wildcard certificate template
var wildcardTemplate = `# Wildcard certificate for *.{{DOMAIN}}
# Auto-generated by watcher - do not edit manually
# Services using subdomains of {{DOMAIN}} will automatically use this certificate

*.{{DOMAIN}} {
    import tls
    abort
}
`

// WriteWildcardConfigs generates wildcard certificate configs for the specified domains
func (m *CaddyManager) WriteWildcardConfigs(domains []string) error {
	if len(domains) == 0 {
		return nil
	}

	// Wildcards go into hosts root directory (global configs like base.conf)
	dir := m.hostsDir

	// Ensure directory exists
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}
	os.Chown(dir, 1000, 1000)

	for _, domain := range domains {
		filename := fmt.Sprintf("wildcard.%s.conf", domain)
		path := filepath.Join(dir, filename)

		// Generate content from template
		content := wildcardTemplate
		content = strings.ReplaceAll(content, "{{DOMAIN}}", domain)

		// Write atomically via temp file
		tmpPath := path + ".tmp"
		if err := os.WriteFile(tmpPath, []byte(content), 0644); err != nil {
			return fmt.Errorf("failed to write temp file: %v", err)
		}

		if err := os.Rename(tmpPath, path); err != nil {
			os.Remove(tmpPath)
			return fmt.Errorf("failed to rename temp file: %v", err)
		}
		os.Chown(path, 1000, 1000)

		log.Printf("Generated wildcard config: wildcard.%s.conf", domain)
	}

	return nil
}

// GetWildcardDomains returns the list of configured wildcard domains from config files
func (m *CaddyManager) GetWildcardDomains() []string {
	m.mu.RLock()
	defer m.mu.RUnlock()

	var domains []string

	entries, err := os.ReadDir(m.hostsDir)
	if err != nil {
		return domains
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		// Match wildcard.*.conf pattern
		if strings.HasPrefix(name, "wildcard.") && strings.HasSuffix(name, ".conf") {
			// Extract domain: wildcard.example.com.conf -> example.com
			domain := strings.TrimPrefix(name, "wildcard.")
			domain = strings.TrimSuffix(domain, ".conf")
			domains = append(domains, domain)
		}
	}

	return domains
}
